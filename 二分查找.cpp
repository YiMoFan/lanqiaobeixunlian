/*题目内容：

dyr有n根网线，每根网线长度Li米，现需要提供k根同等长度的网线。可以对dyr的网线进行分割，问可以提供的网线最大长度是多少？
（网线不可拼接）

Hint
追加：本题卡了精度，由题目可知，给出n的个实数小数位均不超过两位，而最终输出的数据也只需要保留两位小数，
于是可以先把所有数据乘以100转为整数，经过一系列对这些整数的处理得出结果长度（整数），再除以100进行输出。
思想：二分枚举提供的k根网线长度，然后判断该长度是否是合法的。
依据是否合法，决定下一步的策略。

输入描述
输入在第一行给出两个正整数n和k（0<=n，k<=1000）。
随后在第二行给出n个实数(小数位不超过两位)，表示dyr拥有的每根网线的长度（1<=Li<=1000）。

输出描述
在一行中输出可以提供的网线最大长度。（保留两位小数）

输入样例
4 11
8.02 7.43 4.57 5.39

输出样例
2.00
首先，输入输出都是最多只有二位小数，所以先把所有数据都乘以100，这样就是对整数进行二分了。
然后得出结果之后，再把结果除以100输出。

关于二分搜索 开始时下限是 0，(考虑到例如只有一根一米的线，而要分成100段的情况)上限是所有网线
中的最大长度，(因为短的线可能被丢弃不用，而如超出最长网线的长度则无法分割)。

开始判断时，就是直接的二分搜索。如果合法就先记录该数据，然后向更大的数据搜，不合法就向更小的数据搜。
*/
#include "stdio.h"

int n,k;
int num[1000];

int panduan(int temp) {
	int sum = 0;
	for (int i = 0 ; i < n ; i ++) {
		sum = sum + num[i] / temp;
	}
	if (sum >= k) 
		return 1;
	else 
		return 0;
}

int main () {
	int max = 0;
	scanf("%d %d",&n,&k);
	for (int i = 0; i < n; i++) {
		double temp;
		scanf ("%lf",&temp);
		num[i] = temp * 100;
		if (num[i] > max)
			max = num[i];
	}
	int left = 0, right = max;
	int mid;
	int ans;
	while (left <= right) {
		mid = (left + right) / 2;
		if (panduan(mid)) {
			ans = mid;
			left = mid + 1;
		}
		else 
			right = mid - 1;
	}
	printf ("%.2lf",ans * 0.01);
	
	return 0;
	
}

